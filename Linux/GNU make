GNU make
	Problems and Bugs
		Once you have a precise problem you can report it in one of two ways.
		Either send electronic mail to:
			bug-make@gnu.org
		or use our Web-based project management tool, at:
			http://savannah.gnu.org/projects/make/
			
		In addition to the information above, please be careful to include the version number of make you are using. 
		You can get this information with the command ‘make --version’.
		Be sure also to include the type of machine and operating system you are using.
		One way to obtain this information is by looking at the final lines of output from the command ‘make --help’.	
		
		
	1. An Introduction to Makefiles
		You need a file called a makefile to tell make what to do. Most often, the makefile tells make how to compile and link a program.
		
		The makefile can also tell make how to run miscellaneous commands when explicitly asked
		
		When make recompiles the editor, each changed C source file must be recompiled. If a header file has changed, each C source file that includes the header file must be recompiled to be safe. 
		
		Each compilation produces an object file corresponding to the source file. 
		
		Finally, if any source file has been recompiled, all the object files, whether newly made or saved from previous compilations, must be linked together to produce the new executable editor.
		
		1.1 What a Rule Looks Like
			A simple makefile consists of “rules” with the following shape:
				target … : prerequisites …
						recipe
						…
						…
			A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ 
		
			A prerequisite is a file that is used as input to create the target. A target often depends on several files.
			
			A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line.
			Please note: you need to put a tab character at the beginning of every recipe line!
			If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character
			
			the rule that specifies a recipe for the target need not have prerequisites. For example, the rule containing the delete command associated with the target ‘clean’ does not have prerequisites.
			
			A rule, then, explains how and when to remake certain files which are the targets of the particular rule. make carries out the recipe on the prerequisites to create or update the target.
			
		1.2 A Simple Makefile
			Targets that do not refer to files but are just actions are called phony targets.
			
			
				edit : main.o kbd.o command.o display.o \
					   insert.o search.o files.o utils.o
						cc -o edit main.o kbd.o command.o display.o \
								   insert.o search.o files.o utils.o

				main.o : main.c defs.h
						cc -c main.c
				kbd.o : kbd.c defs.h command.h
						cc -c kbd.c
				command.o : command.c defs.h command.h
						cc -c command.c
				display.o : display.c defs.h buffer.h
						cc -c display.c
				insert.o : insert.c defs.h buffer.h
						cc -c insert.c
				search.o : search.c defs.h buffer.h
						cc -c search.c
				files.o : files.c defs.h buffer.h command.h
						cc -c files.c
				utils.o : utils.c defs.h
						cc -c utils.c
				clean :
						rm edit main.o kbd.o command.o display.o \
						   insert.o search.o files.o utils.o
						   
						   
			
		1.3 How make Processes a Makefile
			By default, make starts with the first target. This is called the default goal. 
			
			Goals are the targets that make strives ultimately to update. You can override this behavior using the command line or with the .DEFAULT_GOAL special variable

			In the example, this rule is for relinking edit; but before make can fully process this rule, it must process the rules for the files that edit depends on, which in this case are the object files.
			Each of these files is processed according to its own rule. These rules say to update each ‘.o’ file by compiling its source file.
			The recompilation must be done if the source file, or any of the header files named as prerequisites, is more recent than the object file, or if the object file does not exist.	
			
			After recompiling whichever object files need it, make decides whether to relink edit. This must be done if the file edit does not exist, or if any of the object files are newer than it. 
			If an object file was just recompiled, it is now newer than edit, so edit is relinked.
			
			
		1.4 Variables Make Makefiles Simpler
			
			In our example, we had to list all the object files twice in the rule for edit 
				edit : main.o kbd.o command.o display.o \
							  insert.o search.o files.o utils.o
						cc -o edit main.o kbd.o command.o display.o \
								   insert.o search.o files.o utils.o
								   
			Such duplication is error-prone; if a new object file is added to the system, we might add it to one list and forget the other.
			We can eliminate the risk and simplify the makefile by using a variable.
			
			It is standard practice for every makefile to have a variable named objects, OBJECTS, objs, OBJS, obj, or OBJ which is a list of all object file names. 
				objects = main.o kbd.o command.o display.o \
							insert.o search.o files.o utils.o
							
			Then, each place we want to put a list of the object file names, we can substitute the variable’s value by writing ‘$(objects)’ 
			
			Here is how the complete simple makefile looks when you use a variable for the object files:
				objects = main.o kbd.o command.o display.o \
						  insert.o search.o files.o utils.o

				edit : $(objects)
						cc -o edit $(objects)
				main.o : main.c defs.h
						cc -c main.c
				kbd.o : kbd.c defs.h command.h
						cc -c kbd.c
				command.o : command.c defs.h command.h
						cc -c command.c
				display.o : display.c defs.h buffer.h
						cc -c display.c
				insert.o : insert.c defs.h buffer.h
						cc -c insert.c
				search.o : search.c defs.h buffer.h
						cc -c search.c
				files.o : files.c defs.h buffer.h command.h
						cc -c files.c
				utils.o : utils.c defs.h
						cc -c utils.c
				clean :
						rm edit $(objects)
						
		
		1.5 Letting make Deduce the Recipes
			make can figure them out: it has an implicit rule for updating a ‘.o’ file from a correspondingly named ‘.c’ file using a ‘cc -c’ command.
			When a ‘.c’ file is used automatically in this way, it is also automatically added to the list of prerequisites. We can therefore omit the ‘.c’ files from the prerequisites, provided we omit the recipe.
				objects = main.o kbd.o command.o display.o \
						  insert.o search.o files.o utils.o

				edit : $(objects)
						cc -o edit $(objects)

				main.o : defs.h
				kbd.o : defs.h command.h
				command.o : defs.h command.h
				display.o : defs.h buffer.h
				insert.o : defs.h buffer.h
				search.o : defs.h buffer.h
				files.o : defs.h buffer.h command.h
				utils.o : defs.h

				.PHONY : clean
				clean :
						rm edit $(objects)
			
		1.6 Another Style of Makefile
			When the objects of a makefile are created only by implicit rules, an alternative style of makefile is possible. In this style of makefile, you group entries by their prerequisites instead of by their targets. Here is what one looks like:
				objects = main.o kbd.o command.o display.o \
						  insert.o search.o files.o utils.o

				edit : $(objects)
						cc -o edit $(objects)

				$(objects) : defs.h
				kbd.o command.o files.o : command.h
				display.o insert.o search.o files.o : buffer.h
		
			Here defs.h is given as a prerequisite of all the object files; command.h and buffer.h are prerequisites of the specific object files listed for them.
			
		1.7 Rules for Cleaning the Directory
			Makefiles commonly tell how to do a few other things besides compiling a program: 
			Here is how we could write a make rule for cleaning our example editor:
				clean:
					rm edit $(objects)
			
			In practice, we might want to write the rule in a somewhat more complicated manner to handle unanticipated situations.
			We would do this:	
				.PHONY : clean
				clean :
						-rm edit $(objects)
						
			This prevents make from getting confused by an actual file called clean and causes it to continue in spite of errors from rm. 

	2 Writing Makefiles	
		The information that tells make how to recompile a system comes from reading a data base called the makefile.
		
		2.1 What Makefiles Contain
			Makefiles contain five kinds of things: 
				explicit rules,
				implicit rules,
				variable definitions,
				directives,
				and comments. 
			
			An explicit rule says when and how to remake one or more files, called the rule’s targets. (Writing Rules)
			
			An implicit rule says when and how to remake a class of files based on their names.
			
			A variable definition is a line that specifies a text string value for a variable that can be substituted into the text later.
			
			A directive is an instruction for make to do something special while reading the makefile. 
			These include:
				Reading another makefile 
				Deciding (based on the values of variables) whether to use or ignore a part of the makefile
				Defining a variable from a verbatim string containing multiple lines (Multi-Line Variables).
			
			‘#’ in a line of a makefile starts a comment. 
			You cannot use comments within variable references or function calls: any instance of # will be treated literally
			Comments within a recipe are passed to the shell, just as with any other recipe text. The shell decides how to interpret it: 
				whether or not this is a comment is up to the shell.
			Within a define directive, comments are not ignored during the definition of the variable, but rather kept intact in the value of the variable. 
			When the variable is expanded they will either be treated as make comments or as recipe text, 
			depending on the context in which the variable is evaluated.
			
			2.1.1 Splitting Long Lines
				Makefiles use a “line-based” syntax in which the newline character is special and marks the end of a statement. 
				GNU make has no limit on the length of a statement line, up to the amount of memory in your computer.
				
				The way in which backslash/newline combinations are handled depends on whether the statement is a recipe line or a non-recipe line. 
				Outside of recipe lines, backslash/newlines are converted into a single space character. 
				Once that is done, all whitespace around the backslash/newline is condensed into a single space: this includes all whitespace preceding the backslash,
				all whitespace at the beginning of the line after the backslash/newline,
				and any consecutive backslash/newline combinations.
				
				Splitting Without Adding Whitespace
					If you need to split a line but do not want any whitespace added, you can utilize a subtle trick:
						replace your backslash/newline pairs with the three characters dollar sign/backslash/newline:
							var := one$\
									word
						
					After make removes the backslash/newline and condenses the following line into a single space,
					this is equivalent to:	
						var := one$ word
						
					Then make will perform variable expansion. The variable reference ‘$ ’ refers to a variable with the one-character name “ ” (space) which does not exist, and so expands to the empty string,
					giving a final assignment which is the equivalent of:	
						var := oneword
						
		2.2 What Name to Give Your Makefile	
		
			By default, when make looks for the makefile, it tries the following names, in order:
				GNUmakefile, makefile and Makefile.
			
			Normally you should call your makefile either makefile or Makefile.
			(We recommend Makefile because it appears prominently near the beginning of a directory listing, right near other important files such as README.)
			The first name checked, GNUmakefile, is not recommended for most makefiles.
			You should use this name if you have a makefile that is specific to GNU make, and will not be understood by other versions of make.
			Other make programs look for makefile and Makefile, but not GNUmakefile.
			
			If make finds none of these names, it does not use any makefile. 
			Then you must specify a goal with a command argument, and make will attempt to figure out how to remake it using only its built-in implicit rules.
		
			If you want to use a nonstandard name for your makefile, you can specify the makefile name with the ‘-f’ or ‘--file’ option.
			The default makefile names GNUmakefile, makefile and Makefile are not checked automatically if you specify ‘-f’ or ‘--file’.
			
		2.3 Including Other Makefiles	
		
			The include directive tells make to suspend reading the current makefile and read one or more other makefiles before continuing. 
				include filenames…
			
			filenames can contain shell file name patterns. If filenames is empty, nothing is included and no error is printed.
				
			Extra spaces are allowed and ignored at the beginning of the line, but the first character must not be a tab (or the value of .RECIPEPREFIX)
			
			For example, if you have three .mk files, a.mk, b.mk, and c.mk, and $(bar) expands to bish bash, then the following expression
				include foo *.mk $(bar)
			is equivalent to
				include foo a.mk b.mk c.mk bish bash
		
			If the specified name does not start with a slash, and the file is not found in the current directory, several other directories are searched. 
			First, any directories you have specified with the ‘-I’ or ‘--include-dir’ option are searched
			Then the following directories (if they exist) are searched, in this order:
				prefix/include (normally /usr/local/include 1) /usr/gnu/include, 
				/usr/local/include,
				/usr/include.
			
			If an included makefile cannot be found in any of these directories, a warning message is generated, but it is not an immediately fatal error;
			processing of the makefile containing the include continues. 
			
			Once it has finished reading makefiles, make will try to remake any that are out of date or don’t exist.
			
			Only after it has tried to find a way to remake a makefile and failed, will make diagnose the missing makefile as a fatal error.
			
			If you want make to simply ignore a makefile which does not exist or cannot be remade, with no error message, use the -include directive instead of include, like this:
				-include filenames…
				
			For compatibility with some other make implementations, sinclude is another name for -include.

		
		2.4 The Variable MAKEFILES	
		
			If the environment variable MAKEFILES is defined, make considers its value as a list of names (separated by whitespace) of additional makefiles to be read before the others.
			This works much like the include directive: 
			
			The main use of MAKEFILES is in communication between recursive invocations of make 
			
			It usually is not desirable to set the environment variable before a top-level invocation of make, because it is usually better not to mess with a makefile from outside. 
			
			However, if you are running make without a specific makefile, a makefile in MAKEFILES can do useful things to help the built-in implicit rules work better, such as defining search paths
			
			Some users are tempted to set MAKEFILES in the environment automatically on login, and program makefiles to expect this to be done. This is a very bad idea, because such makefiles will fail to work if run by anyone else. 
			It is much better to write explicit include directives in the makefiles.
			
		2.5 How Makefiles Are Remade	
		
			Sometimes makefiles can be remade from other files, such as RCS or SCCS files.
			If a makefile can be remade from other files, you probably want make to get an up-to-date version of the makefile to read in.
			
			After all makefiles have been checked, if any have actually been changed, make starts with a clean slate and reads all the makefiles over again.
			
			Each restart will cause the special variable MAKE_RESTARTS to be updated 
			
			If you know that one or more of your makefiles cannot be remade and you want to keep make from performing an implicit rule search on them, perhaps for efficiency reasons, you can use any normal method of preventing implicit rule look-up to do so.
			For example, you can write an explicit rule with the makefile as the target, and an empty recipe 
			
			If the makefiles specify a double-colon rule to remake a file with a recipe but no prerequisites, that file will always be remade
			In the case of makefiles, a makefile that has a double-colon rule with a recipe but no prerequisites will be remade every time make is run, and then again after make starts over and reads the makefiles in again. This would cause an infinite loop: 
				make would constantly remake the makefile, and never do anything else.
				
			If you do not specify any makefiles to be read with ‘-f’ or ‘--file’ options, make will try the default makefile names; 
			Unlike makefiles explicitly requested with ‘-f’ or ‘--file’ options, make is not certain that these makefiles should exist. 
			
			When you use the ‘-t’ or ‘--touch’ option you would not want to use an out-of-date makefile to decide which targets to touch.
			 Likewise, ‘-q’ (or ‘--question’) and ‘-n’ (or ‘--just-print’) do not prevent updating of makefiles, because an out-of-date makefile would result in the wrong output for other targets. 
			 Thus,
				make -f mfile -n foo
				will update mfile, read it in, and then print the recipe to update foo and its prerequisites without running it.
				The recipe printed for foo will be the one specified in the updated contents of mfile.
				
			However, on occasion you might actually wish to prevent updating of even the makefiles. 	
			You can do this by specifying the makefiles as goals in the command line as well as specifying them as makefiles.
			Thus, 
				make -f mfile -n mfile foo
				would read the makefile mfile, print the recipe needed to update it without actually running it, and then print the recipe needed to update foo without running that.
				
				
		2.6 Overriding Part of Another Makefile
			
			You can often use the ‘include’ directive to include one in the other, and add more targets or variable definitions. However, it is invalid for two makefiles to give different recipes for the same target.
			But there is another way.
			
			In the containing makefile (the one that wants to include the other), you can use a match-anything pattern rule to say that to remake any target that cannot be made from the information in the containing makefile,
			make should look in another makefile.
			
			For example, if you have a makefile called Makefile that says how to make the target ‘foo’ (and other targets),
			you can write a makefile called GNUmakefile that contains:
				foo:
						frobnicate > foo

				%: force
						@$(MAKE) -f Makefile $@
				force: ;
				
				If you say ‘make foo’, make will find GNUmakefile, read it, and see that to make foo,
				it needs to run the recipe ‘frobnicate > foo’. 
		
				If you say ‘make bar’, make will find no way to make bar in GNUmakefile,
				so it will use the recipe from the pattern rule:
					make -f Makefile bar
				
					If Makefile provides a rule for updating bar, make will apply the rule.
					
					The way this works is that the pattern rule has a pattern of just ‘%’, so it matches any target whatever. 
					The rule specifies a prerequisite force, to guarantee that the recipe will be run even if the target file already exists.
					
					We give the force target an empty recipe to prevent make from searching for an implicit rule to build it
					otherwise it would apply the same match-anything rule to force itself and create a prerequisite loop!
					
					
		2.7 How make Reads a Makefile	
			
			GNU make does its work in two distinct phases. 
			
			 During the first phase it reads all the makefiles, included makefiles, etc. and internalizes all the variables and their values and implicit and explicit rules, and builds a dependency graph of all the targets and their prerequisites.
			 
			 During the second phase, make uses this internalized data to determine which targets need to be updated and run the recipes necessary to update them.
			 
			 It’s important to understand this two-phase approach because it has a direct impact on how variable and function expansion happens; 
			 
			 We say that expansion is immediate if it happens during the first phase: make will expand that part of the construct as the makefile is parsed.
			 
			 We say that expansion is deferred if it is not immediate. Expansion of a deferred construct part is delayed until the expansion is used: 
			 
				Variable Assignment
					
					Variable definitions are parsed as follows:
						immediate = deferred
						immediate ?= deferred
						immediate := immediate
						immediate ::= immediate
						immediate += deferred or immediate
						immediate != immediate

						define immediate
						  deferred
						endef

						define immediate =
						  deferred
						endef

						define immediate ?=
						  deferred
						endef

						define immediate :=
						  immediate
						endef

						define immediate ::=
						  immediate
						endef

						define immediate +=
						  deferred or immediate
						endef

						define immediate !=
						  immediate
						endef
					
					For the append operator ‘+=’, 
					the right-hand side is considered immediate if the variable was previously set as a simple variable (‘:=’ or ‘::=’),
					and deferred otherwise.
					
					For the shell assignment operator ‘!=’, the right-hand side is evaluated immediately and handed to the shell.
					The result is stored in the variable named on the left, and that variable becomes a simple variable
					
				Conditional Directives
					
					Conditional directives are parsed immediately.
					
					Rule Definition
					A rule is always expanded the same way, regardless of the form:
						immediate : immediate ; deferred
								deferred
			
						That is, the target and prerequisite sections are expanded immediately, and the recipe used to build the target is always deferred.
						
						
		2.8 How Makefiles Are Parsed
			GNU make parses makefiles line-by-line. Parsing proceeds using the following steps:
			1. Read in a full logical line, including backslash-escaped lines
			2. Remove comments 
			3. If the line begins with the recipe prefix character and we are in a rule context,
				add the line to the current recipe and read the next line 
			4. Expand elements of the line which appear in an immediate expansion context
			5. Scan the line for a separator character, such as ‘:’ or ‘=’, to determine whether the line is a macro assignment or a rule 
			6. Internalize the resulting operation and read the next line.
			
			An important consequence of this is that a macro can expand to an entire rule, if it is one line long. 
			This will work:
				myrule = target : ; echo built

				$(myrule)
				
			However, this will not work because make does not re-split lines after it has expanded them:
				define myrule
				target:
						echo built
				endef

				$(myrule)	
				The above makefile results in the definition of a target ‘target’ with prerequisites ‘echo’ and ‘built’, as if the makefile contained target: echo built, rather than a rule with a recipe. Newlines still present in a line after expansion is complete are ignored as normal whitespace.
				
			In order to properly expand a multi-line macro you must use the eval function: 

		2.9 Secondary Expansion		
			
			Previously we learned that GNU make works in two distinct phases:
			a read-in phase and a target-update phase	
			GNU make also has the ability to enable a second expansion of the prerequisites (only) for some or all targets defined in the makefile.
			In order for this second expansion to occur, the special target .SECONDEXPANSION must be defined before the first prerequisite list that makes use of this feature.
			
			If that special target is defined then in between the two phases mentioned above, right at the end of the read-in phase, all the prerequisites of the targets defined after the special target are expanded a second time. 
			In order to take advantage of the secondary expansion phase of the parser, then, it’s necessary to escape the variable or function reference in the makefile. In this case the first expansion merely un-escapes the reference but doesn’t expand it, and expansion is left to the secondary expansion phase.
			For example, consider this makefile:
				.SECONDEXPANSION:
				ONEVAR = onefile
				TWOVAR = twofile
				myfile: $(ONEVAR) $$(TWOVAR)
				
				After the first expansion phase the prerequisites list of the myfile target will be onefile and $(TWOVAR);
				the first (unescaped) variable reference to ONEVAR is expanded, while the second (escaped) variable reference is simply unescaped, without being recognized as a variable reference. 
				 Now during the secondary expansion the first word is expanded again but since it contains no variable or function references it remains the value onefile, while the second word is now a normal reference to the variable TWOVAR, which is expanded to the value twofile. 
				 The final result is that there are two prerequisites, onefile and twofile.
				 
			consider this example:
				.SECONDEXPANSION:
				AVAR = top
				onefile: $(AVAR)
				twofile: $$(AVAR)
				AVAR = bottom
				
				Here the prerequisite of onefile will be expanded immediately, and resolve to the value top, while the prerequisite of twofile will not be full expanded until the secondary expansion and yield a value of bottom.
			
			secondary expansions always take place within the scope of the automatic variables for that target
			you can use variables such as $@, $*, etc. during the second expansion and they will have their expected values, just as in the recipe.
				.SECONDEXPANSION:
				main_OBJS := main.o try.o test.o
				lib_OBJS := lib.o api.o

				main lib: $$($$@_OBJS)
				
				Here, after the initial expansion the prerequisites of both the main and lib targets will be $($@_OBJS).
				During the secondary expansion,
				the $@ variable is set to the name of the target and so the expansion for the main target will yield $(main_OBJS), or main.o try.o test.o,
				while the secondary expansion for the lib target will yield $(lib_OBJS), 
				or lib.o api.o.
				
			Secondary Expansion of Explicit Rules
				
				During the secondary expansion of explicit rules, $$@ and $$% evaluate, respectively, to the file name of the target and, when the target is an archive member, the target member name.
				The $$< variable evaluates to the first prerequisite in the first rule for this target.
				$$^ and $$+ evaluate to the list of all prerequisites of rules that have already appeared for the same target ($$+ with repetitions and $$^ without). 
				The following example will help illustrate these behaviors:
					.SECONDEXPANSION:

					foo: foo.1 bar.1 $$< $$^ $$+    # line #1

					foo: foo.2 bar.2 $$< $$^ $$+    # line #2

					foo: foo.3 bar.3 $$< $$^ $$+    # line #3
		
				In the first prerequisite list, all three variables ($$<, $$^, and $$+) expand to the empty string.
				In the second, they will have values foo.1, foo.1 bar.1, and foo.1 bar.1 respectively.
				In the third they will have values foo.1, foo.1 bar.1 foo.2 bar.2, and foo.1 bar.1 foo.2 bar.2 foo.1 foo.1 bar.1 foo.1 bar.1 respectively.
				
				Rules undergo secondary expansion in makefile order, except that the rule with the recipe is always evaluated last.
				
				The variables $$? and $$* are not available and expand to the empty string.
				
			Secondary Expansion of Static Pattern Rules
				
				Rules for secondary expansion of static pattern rules are identical to those for explicit rules, above, with one exception:
				for static pattern rules the $$* variable is set to the pattern stem. 
				As with explicit rules, $$? is not available and expands to the empty string.
		
			Secondary Expansion of Implicit Rules
				
				As make searches for an implicit rule, it substitutes the stem and then performs secondary expansion for every rule with a matching target pattern. The value of the automatic variables is derived in the same fashion as for static pattern rules. 
					.SECONDEXPANSION:

					foo: bar

					foo foz: fo%: bo%

					%oo: $$< $$^ $$+ $$*
		
					When the implicit rule is tried for target foo, 
					$$< expands to bar, 
					$$^ expands to bar boo, 
					$$+ also expands to bar boo, and $$* expands to f.
					
		3 Writing Rules
			A rule appears in the makefile and says when and how to remake certain files, called the rule’s targets.
			It lists the other files that are the prerequisites of the target, and the recipe to use to create or update the target.
			a target starting with a period is not a default unless it contains one or more slashes, ‘/’, as well; and, 
			a target that defines a pattern rule has no effect on the default goal.
			
			3.1 Rule Example
				Here is an example of a rule:
					foo.o : foo.c defs.h       # module for twiddling the frobs
							cc -c -g foo.c
					
				This rule says two things:
				1. How to decide whether foo.o is out of date: it is out of date if it does not exist, or if either foo.c or defs.h is more recent than it.
				2. How to update the file foo.o: by running cc as stated. The recipe does not explicitly mention defs.h, but we presume that foo.c includes it,
					and that is why defs.h was added to the prerequisites.	
			
			3.2 Rule Syntax
				In general, a rule looks like this:
					targets : prerequisites
							recipe
							…
				
				or like this:
					targets : prerequisites ; recipe
							recipe
							…
					
				Because dollar signs are used to start make variable references, if you really want a dollar sign in a target or prerequisite you must write two of them, ‘$$’ 
				
				If you have enabled secondary expansion (see Secondary Expansion) and you want a literal dollar sign in the prerequisites list, you must actually write four dollar signs (‘$$$$’).
					
			3.3 Types of Prerequisites	
				There are actually two different types of prerequisites understood by GNU make: normal prerequisites, and order-only prerequisites.
				A normal prerequisite makes two statements:
					1. first, it imposes an order in which recipes will be invoked: the recipes for all prerequisites of a target will be completed before the recipe for the target is run. 
					2. Second, it imposes a dependency relationship: if any prerequisite is newer than the target, then the target is considered out-of-date and must be rebuilt.
					
				Normally, this is exactly what you want: if a target’s prerequisite is updated, then the target should also be updated.
					
				Occasionally, however, you have a situation where you want to impose a specific ordering on the rules to be invoked without forcing the target to be updated if one of those rules is executed. 
				In that case, you want to define order-only prerequisites.
				Order-only prerequisites can be specified by placing a pipe symbol (|) in the prerequisites list:
					any prerequisites to the left of the pipe symbol are normal;
					any prerequisites to the right are order-only:
						targets : normal-prerequisites | order-only-prerequisites
						
					The normal prerequisites section may of course be empty.
					Note that if you declare the same file to be both a normal and an order-only prerequisite, the normal prerequisite takes precedence
					
						OBJDIR := objdir
						OBJS := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)

						$(OBJDIR)/%.o : %.c
								$(COMPILE.c) $(OUTPUT_OPTION) $<

						all: $(OBJS)

						$(OBJS): | $(OBJDIR)

						$(OBJDIR):
								mkdir $(OBJDIR)
								
					Now the rule to create the objdir directory will be run, if needed,
					before any ‘.o’ is built, 
					but no ‘.o’ will be built because the objdir directory timestamp changed.			
					
			3.4 Using Wildcard Characters in File Names		
				A single file name can specify many files using wildcard characters. 
				
				The wildcard characters in make are ‘*’, ‘?’ and ‘[…]’, the same as in the Bourne shell.
				
				Wildcard expansion is performed by make automatically in targets and in prerequisites. In recipes, the shell is responsible for wildcard expansion. 
				
				The special significance of a wildcard character can be turned off by preceding it with a backslash. 
				
				3.4.1 Wildcard Examples
					Wildcards can be used in the recipe of a rule, where they are expanded by the shell.
					For example, here is a rule to delete all the object files:
						clean:
							rm -f *.o
					
						
					Wildcards are also useful in the prerequisites of a rule.
					With the following rule in the makefile, 
					‘make print’ will print all the ‘.c’ files that have changed since the last time you printed them:
						print: *.c
								lpr -p $?
								touch print
		
					This rule uses print as an empty target file;
					
					Wildcard expansion does not happen when you define a variable.
						objects = *.o
					then the value of the variable objects is the actual string ‘*.o’. However, if you use the value of objects in a target or prerequisite, wildcard expansion will take place there.
						
					To set objects to the expansion, instead use:
						objects := $(wildcard *.o)
		
				3.4.2 Pitfalls of Using Wildcards
					Suppose you would like to say that the executable file foo is made from all the object files in the directory, and you write this:
						objects = *.o

						foo : $(objects)
								cc -o foo $(CFLAGS) $(objects)
								
					The value of objects is the actual string ‘*.o’. Wildcard expansion happens in the rule for foo,
					so that each existing ‘.o’ file becomes a prerequisite of foo and will be recompiled if necessary.			
					
					But what if you delete all the ‘.o’ files? When a wildcard matches no files, it is left as it is, so then foo will depend on the oddly-named file *.o. Since no such file is likely to exist, make will give you an error saying it cannot figure out how to make *.o. 
					This is not what you want!
		
				3.4.3 The Function wildcard
					Wildcard expansion happens automatically in rules. But wildcard expansion does not normally take place when a variable is set,
					or inside the arguments of a function.
					
					One use of the wildcard function is to get a list of all the C source files in a directory, 
					like this:
						$(wildcard *.c)
					
					We can change the list of C source files into a list of object files by replacing the ‘.c’ suffix with ‘.o’ in the result,
					like this:	
						$(patsubst %.c,%.o,$(wildcard *.c))
						
					Thus, a makefile to compile all C source files in the directory and then link them together could be written as follows:
						objects := $(patsubst %.c,%.o,$(wildcard *.c))

						foo : $(objects)
								cc -o foo $(objects)
		
			3.5 Searching Directories for Prerequisites
				For large systems, it is often desirable to put sources in a separate directory from the binaries.
				The directory search features of make facilitate this by searching several directories automatically to find a prerequisite.
				
				3.5.1 VPATH: Search Path for All Prerequisites
					The value of the make variable VPATH specifies a list of directories that make should search.
					make uses VPATH as a search list for both prerequisites and targets of rules.
					
					In the VPATH variable, directory names are separated by colons or blanks. 
					
					The order in which directories are listed is the order followed by make in its search.
					For example,
						VPATH = src:../headers
						specifies a path containing two directories, src and ../headers, which make searches in that order.
						
						With this value of VPATH, the following rule,
							foo.o : foo.c
						is interpreted as if it were written like this:
							foo.o : src/foo.c
						assuming the file foo.c does not exist in the current directory but is found in the directory src.

				3.5.2 The vpath Directive
					allows you to specify a search path for a particular class of file names: 
					those that match a particular pattern. 
					Thus you can supply certain search directories for one class of file names and other directories (or none) for other file names.
					
					There are three forms of the vpath directive:
						vpath pattern directories
							Specify the search path directories for file names that match pattern.
							The search path, directories, is a list of directories to be searched, separated by colons
							
						vpath pattern
							Clear out the search path associated with pattern.
						
						vpath	
							Clear all search paths previously specified with vpath directives.
						
					A vpath pattern is a string containing a ‘%’ character.
					The string must match the file name of a prerequisite that is being searched for, the ‘%’ character matching any sequence of zero or more characters
					For example,
						vpath %.h ../headers
						tells make to look for any prerequisite whose name ends in .h in the directory ../headers if the file is not found in the current directory.
						
					make handles multiple vpath directives in the order in which they appear in the makefile; multiple directives with the same pattern are independent of each other.
					Thus,
						vpath %.c foo
						vpath %   blish
						vpath %.c bar
						will look for a file ending in ‘.c’ in foo, then blish, then bar, while
					
						vpath %.c foo:bar
						vpath %   blish
						will look for a file ending in ‘.c’ in foo, then bar, then blish.
						
				3.5.3 How Directory Searches are Performed	
					When a prerequisite is found through directory search,
					regardless of type (general or selective), the pathname located may not be the one that make actually provides you in the prerequisite list. 
					Sometimes the path discovered through directory search is thrown away.
					The algorithm make uses to decide whether to keep or abandon a path found via directory search is as follows:
						1. If a target file does not exist at the path specified in the makefile, directory search is performed.
						2. If the directory search is successful, that path is kept and this file is tentatively stored as the target.
						3. All prerequisites of this target are examined using this same method.
						4. After processing the prerequisites, the target may or may not need to be rebuilt:
							1. If the target does not need to be rebuilt, the path to the file found during directory search is used for any prerequisite lists which contain this target.
								In short, if make doesn’t need to rebuild the target then you use the path found via directory search.
							2. If the target does need to be rebuilt (is out-of-date), the pathname found during directory search is thrown away, and the target is rebuilt using the file name specified in the makefile.
								In short, if make must rebuild, then the target is rebuilt locally, not in the directory found via directory search.
						
					Other versions of make use a simpler algorithm: 
						 if the file does not exist, and it is found via directory search, then that pathname is always used whether or not the target needs to be built.
						 Thus, if the target is rebuilt it is created at the pathname discovered during directory search.

					If, in fact, this is the behavior you want for some or all of your directories, you can use the GPATH variable to indicate this to make.
						GPATH has the same syntax and format as VPATH
						If an out-of-date target is found by directory search in a directory that also appears in GPATH, then that pathname is not thrown away. 
						The target is rebuilt using the expanded path.

				3.5.4 Writing Recipes with Directory Search
					When a prerequisite is found in another directory through directory search, this cannot change the recipe of the rule;
					they will execute as written.	
					Therefore, you must write the recipe with care so that it will look for the prerequisite in the directory where make finds it.
					This is done with the automatic variables such as $^
					For instance,
						the value of $^ is a list of all the prerequisites of the rule, including the names of the directories in which they were found,
						and the value of $@ is the target.
					Thus,
						foo.o : foo.c
								cc -c $(CFLAGS) $^ -o $@
					
					Often the prerequisites include header files as well,
					which you do not want to mention in the recipe.
						The automatic variable ‘$<’ is just the first prerequisite:
							VPATH = src:../headers
							foo.o : foo.c defs.h hack.h
									cc -c $(CFLAGS) $< -o $@
				
				3.5.5 Directory Search and Implicit Rules	
					The search through the directories specified in VPATH or with vpath also happens during consideration of implicit rules 
					For example, when a file foo.o has no explicit rule, make considers implicit rules, such as the built-in rule to compile foo.c if that file exists. If such a file is lacking in the current directory,
					the appropriate directories are searched for it. 
					If foo.c exists (or is mentioned in the makefile) in any of the directories, the implicit rule for C compilation is applied.
					
				3.5.6 Directory Search for Link Libraries	
					Directory search applies in a special way to libraries used with the linker.
					



















							
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		